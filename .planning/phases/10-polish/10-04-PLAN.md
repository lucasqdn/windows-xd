---
phase: 10-polish
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - app/lib/themes.ts
  - app/hooks/useTheme.ts
  - app/globals.css
  - app/contexts/WindowManagerContext.tsx
autonomous: true

must_haves:
  truths:
    - "6 authentic Windows 98 color schemes are available"
    - "Theme switching is instant (<100ms perceived lag)"
    - "Theme persists across browser sessions"
    - "All UI elements respect theme colors"
  artifacts:
    - path: "app/lib/themes.ts"
      provides: "Theme definitions with 6 color schemes"
      min_lines: 150
      exports: ["Theme", "ThemeName", "themes", "defaultTheme"]
    - path: "app/hooks/useTheme.ts"
      provides: "Theme management hook"
      min_lines: 60
      exports: ["useTheme"]
    - path: "app/globals.css"
      provides: "CSS custom properties for theming"
      min_lines: 50
      contains: "--title-bar-active-start"
  key_links:
    - from: "app/hooks/useTheme.ts"
      to: "app/lib/themes.ts"
      via: "Theme data import"
      pattern: "import.*themes.*from"
    - from: "app/hooks/useTheme.ts"
      to: "document.documentElement.style"
      via: "CSS custom property setting"
      pattern: "setProperty"
---

<objective>
Implement theme system foundation with 6 Windows 98 color schemes and CSS custom properties.

Purpose: Enable instant theme switching across entire application
Output: Working theme system with persistence and 6 authentic themes
</objective>

<execution_context>
@/Users/lucas/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/lucas/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-polish/10-CONTEXT.md
@.planning/phases/10-polish/10-RESEARCH.md
@app/globals.css
@app/contexts/WindowManagerContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Create theme definitions with 6 color schemes</name>
  <files>app/lib/themes.ts</files>
  <action>
Create new file `app/lib/themes.ts` with theme data structure and 6 authentic Windows 98 themes:

1. **Define types**:
```typescript
export type ThemeName = 
  | 'windows-standard'
  | 'high-contrast-black'
  | 'brick'
  | 'rainy-day'
  | 'desert'
  | 'eggplant';

export interface Theme {
  name: ThemeName;
  displayName: string;
  colors: {
    titleBarActiveStart: string;
    titleBarActiveEnd: string;
    titleBarInactive: string;
    windowBg: string;
    buttonFace: string;
    buttonHighlight: string;
    buttonShadow: string;
    buttonDarkShadow: string;
    desktopBg: string;
    textPrimary: string;
    textInverse: string;
  };
}
```

2. **Define all 6 themes** using exact color values from RESEARCH.md section 3:
   - **Windows Standard** (teal/navy): titleBarActiveStart: #000080, titleBarActiveEnd: #1084d0, desktopBg: #008080, etc.
   - **High Contrast Black**: windowBg: #000000, textPrimary: #ffff00 (yellow on black)
   - **Brick** (red tones): titleBarActiveStart: #800000, desktopBg: #a05040
   - **Rainy Day** (blue/purple): titleBarActiveStart: #000080, windowBg: #b0c4de
   - **Desert** (tan/brown): titleBarActiveStart: #8b4513, windowBg: #f5deb3
   - **Eggplant** (purple): titleBarActiveStart: #4b0082, desktopBg: #8b008b

3. **Create themes record**:
```typescript
export const themes: Record<ThemeName, Theme> = {
  'windows-standard': { /* ... */ },
  'high-contrast-black': { /* ... */ },
  // ... etc
};
```

4. **Export default theme**:
```typescript
export const defaultTheme: ThemeName = 'windows-standard';
```

**Reference RESEARCH.md section 3 for exact color values.**
  </action>
  <verify>
1. Run: `npx tsc --noEmit`
2. Check that themes.ts compiles with no type errors
3. Verify all 6 themes defined with complete color sets
4. Verify exports are correct (themes, defaultTheme, Theme, ThemeName)
  </verify>
  <done>
themes.ts exists with 6 complete theme definitions. All themes have 11 color properties. Type definitions exported. No TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Add CSS custom properties for theming</name>
  <files>app/globals.css</files>
  <action>
Update the `:root` selector in globals.css to use CSS custom properties for all theme colors:

1. **Find the existing `:root` block** (likely near top of file)

2. **Add theme custom properties** with default theme (Windows Standard) values:
```css
:root {
  /* Existing properties (keep these) */
  --background: #ffffff;
  --foreground: #171717;
  
  /* Theme colors (add these) */
  --title-bar-active-start: #000080;
  --title-bar-active-end: #1084d0;
  --title-bar-inactive: #808080;
  --window-bg: #c0c0c0;
  --button-face: #c0c0c0;
  --button-highlight: #ffffff;
  --button-shadow: #808080;
  --button-dark-shadow: #000000;
  --desktop-bg: #008080;
  --text-primary: #000000;
  --text-inverse: #ffffff;
}
```

3. **Update existing Win98 color references** to use variables:
   - Find any hardcoded `#c0c0c0` (button gray) → `var(--button-face)`
   - Find any hardcoded `#808080` (shadow gray) → `var(--button-shadow)`
   - Find any hardcoded `#000080` (navy) → `var(--title-bar-active-start)`
   - Find desktop background color → `var(--desktop-bg)`

4. **Update window title bar gradients** (if not already using variables):
```css
.window-title-bar.active {
  background: linear-gradient(to right, 
    var(--title-bar-active-start), 
    var(--title-bar-active-end)
  );
}

.window-title-bar.inactive {
  background: var(--title-bar-inactive);
}
```

5. **Update button styles** to use variables:
```css
.win98-button {
  background: var(--button-face);
  border-top: 2px solid var(--button-highlight);
  border-left: 2px solid var(--button-highlight);
  border-right: 2px solid var(--button-dark-shadow);
  border-bottom: 2px solid var(--button-dark-shadow);
  box-shadow:
    inset -1px -1px 0 var(--button-shadow),
    inset 1px 1px 0 var(--button-highlight);
}
```

**Important**: Search and replace all hardcoded Windows 98 colors with CSS variables. This ensures theme switching works globally.
  </action>
  <verify>
1. Run: `npm run build`
2. Check build succeeds with no CSS errors
3. Run: `npm run dev` and verify app still looks correct
4. Visually inspect that default Windows Standard theme is applied
5. Use browser DevTools to temporarily change a CSS variable (e.g., `--desktop-bg: red`) and verify it takes effect instantly
  </verify>
  <done>
globals.css contains CSS custom properties for all 11 theme colors. All existing hardcoded colors replaced with var() references. Default Windows Standard theme applied. App renders correctly with theme variables.
  </done>
</task>

<task type="auto">
  <name>Create useTheme hook with persistence</name>
  <files>app/hooks/useTheme.ts</files>
  <action>
Create new file `app/hooks/useTheme.ts` with theme management:

1. **Import dependencies**:
```typescript
import { useState, useEffect, useCallback } from 'react';
import { themes, defaultTheme, type ThemeName, type Theme } from '@/app/lib/themes';
```

2. **Define hook**:
```typescript
export function useTheme() {
  const [currentTheme, setCurrentTheme] = useState<ThemeName>(defaultTheme);
  
  // Load theme from localStorage on mount
  useEffect(() => {
    const stored = localStorage.getItem('windows-xd-theme') as ThemeName | null;
    if (stored && themes[stored]) {
      setCurrentTheme(stored);
      applyThemeColors(themes[stored]);
    }
  }, []);
  
  const applyThemeColors = useCallback((theme: Theme) => {
    const root = document.documentElement;
    const colorMap = {
      'titleBarActiveStart': '--title-bar-active-start',
      'titleBarActiveEnd': '--title-bar-active-end',
      'titleBarInactive': '--title-bar-inactive',
      'windowBg': '--window-bg',
      'buttonFace': '--button-face',
      'buttonHighlight': '--button-highlight',
      'buttonShadow': '--button-shadow',
      'buttonDarkShadow': '--button-dark-shadow',
      'desktopBg': '--desktop-bg',
      'textPrimary': '--text-primary',
      'textInverse': '--text-inverse',
    };
    
    Object.entries(colorMap).forEach(([key, cssVar]) => {
      const color = theme.colors[key as keyof typeof theme.colors];
      root.style.setProperty(cssVar, color);
    });
  }, []);
  
  const setTheme = useCallback((themeName: ThemeName) => {
    const theme = themes[themeName];
    if (!theme) return;
    
    setCurrentTheme(themeName);
    applyThemeColors(theme);
    localStorage.setItem('windows-xd-theme', themeName);
  }, [applyThemeColors]);
  
  return {
    currentTheme,
    setTheme,
    availableThemes: Object.values(themes),
  };
}
```

3. **Handle SSR gracefully**: Wrap localStorage access in try-catch or check for `typeof window !== 'undefined'`.

4. **Optimize performance**: `applyThemeColors` should be memoized to prevent unnecessary re-application.
  </action>
  <verify>
1. Run: `npx tsc --noEmit`
2. Check that useTheme.ts compiles with no type errors
3. Verify hook exports currentTheme, setTheme, and availableThemes
4. Run: `npm run build` to ensure no build errors
  </verify>
  <done>
useTheme hook exists with theme state management, localStorage persistence, and CSS custom property application. Hook returns currentTheme, setTheme function, and availableThemes array. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Add theme state to WindowManagerContext</name>
  <files>app/contexts/WindowManagerContext.tsx</files>
  <action>
Integrate theme management into the global context so all components can access theme:

1. **Import useTheme hook**:
```typescript
import { useTheme } from '@/app/hooks/useTheme';
```

2. **Add theme to context value**:
```typescript
export function WindowManagerProvider({ children }: { children: React.ReactNode }) {
  // ... existing state
  const theme = useTheme();
  
  return (
    <WindowManagerContext.Provider value={{
      // ... existing context values
      theme, // Add theme object
    }}>
      {children}
    </WindowManagerContext.Provider>
  );
}
```

3. **Update context type**:
```typescript
interface WindowManagerContextType {
  // ... existing properties
  theme: ReturnType<typeof useTheme>;
}
```

**Alternative approach**: If WindowManagerContext is already large, theme could be its own separate ThemeContext. However, for simplicity and because theme affects windows (title bars, buttons), including it in WindowManagerContext makes sense.

**Note**: This makes `useWindowManager()` hook return the theme object, allowing any component to call `const { theme } = useWindowManager(); theme.setTheme('brick');`
  </action>
  <verify>
1. Run: `npx tsc --noEmit`
2. Check that WindowManagerContext.tsx compiles with no type errors
3. Run: `npm run dev`
4. Open browser console and test theme switching:
```javascript
// In console (if you expose windowManager for testing)
// Or add temporary button in UI to test
localStorage.setItem('windows-xd-theme', 'brick');
location.reload(); // Should load with Brick theme
```
5. Verify theme persists across page refreshes
  </verify>
  <done>
WindowManagerContext includes theme object from useTheme hook. All components can access theme via useWindowManager(). Theme persists in localStorage. TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
- [ ] themes.ts defines 6 complete Windows 98 color schemes
- [ ] globals.css uses CSS custom properties for all theme colors
- [ ] useTheme hook manages theme state and localStorage persistence
- [ ] WindowManagerContext provides theme to all components
- [ ] Theme switching applies CSS variables instantly
- [ ] Theme persists across browser sessions
- [ ] All UI elements (windows, buttons, desktop) respect theme colors
- [ ] No TypeScript errors or build errors
</verification>

<success_criteria>
- 6 authentic Windows 98 themes available
- Theme switching instant (<100ms perceived lag)
- Theme persists in localStorage across sessions
- All UI elements (windows, taskbar, Start menu, buttons) update with theme
- CSS custom properties approach (no page reload needed)
- TypeScript strict mode passes
- No console errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-polish/10-04-SUMMARY.md`
</output>
