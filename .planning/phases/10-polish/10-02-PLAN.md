---
phase: 10-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/lib/sounds.ts
  - app/hooks/useSoundEffects.ts
  - app/components/Window.tsx
  - app/components/StartMenu.tsx
  - app/components/apps/Minesweeper.tsx
autonomous: true

must_haves:
  truths:
    - "Window operations produce authentic sound effects"
    - "Sounds use Web Audio API (no audio files)"
    - "Sound volume is controllable and can be muted"
    - "Multiple simultaneous sounds don't cause distortion"
  artifacts:
    - path: "app/lib/sounds.ts"
      provides: "SoundManager class with Web Audio synthesis"
      min_lines: 200
      exports: ["SoundManager", "SoundType"]
    - path: "app/hooks/useSoundEffects.ts"
      provides: "Sound hook using SoundManager"
      min_lines: 60
  key_links:
    - from: "app/components/Window.tsx"
      to: "app/hooks/useSoundEffects.ts"
      via: "playSound hook"
      pattern: "playSound\\(['\"]window"
    - from: "app/hooks/useSoundEffects.ts"
      to: "app/lib/sounds.ts"
      via: "SoundManager import"
      pattern: "new SoundManager"
---

<objective>
Implement comprehensive sound effects system using Web Audio API.

Purpose: Add authentic Windows 98 audio feedback for all UI interactions
Output: Working sound system with window, system, UI, and game sounds
</objective>

<execution_context>
@/Users/lucas/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/lucas/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-polish/10-CONTEXT.md
@.planning/phases/10-polish/10-RESEARCH.md
@app/hooks/useSoundEffects.ts
</context>

<tasks>

<task type="auto">
  <name>Create SoundManager class with Web Audio synthesis</name>
  <files>app/lib/sounds.ts</files>
  <action>
Create a new file `app/lib/sounds.ts` with complete sound synthesis system:

1. **Define SoundType**:
```typescript
export type SoundType = 
  | 'windowOpen' | 'windowClose' | 'windowMinimize' | 'windowMaximize' | 'windowRestore'
  | 'error' | 'criticalStop' | 'exclamation'
  | 'buttonClick' | 'menuOpen' | 'menuClose'
  | 'mineExplode' | 'cardDeal' | 'solitaireWin';
```

2. **Create SoundManager class** with:
   - Private `audioContext: AudioContext | null` (lazy init)
   - Private `volume: number = 0.3`
   - Private `muted: boolean = false`
   - `getContext()`: Lazy initialize AudioContext
   - `setVolume(volume: number)`: Update master volume
   - `setMuted(muted: boolean)`: Toggle mute
   - `playSound(type: SoundType)`: Main entry point

3. **Implement sound synthesis methods**:
   - `playChirp(startFreq, endFreq, duration)`: For window open/close
   - `playBeep(frequency, duration, waveType)`: For system sounds
   - `playClick(frequency, duration)`: For UI sounds
   - `playExplosion()`: Noise burst for mine explosion
   - `playArpeggio(notes, duration)`: For solitaire win

4. **Sound definitions** (from RESEARCH.md):
   - windowOpen: 400Hz → 800Hz chirp, 100ms
   - windowClose: 800Hz → 400Hz chirp, 100ms
   - windowMinimize: 600Hz → 300Hz, 150ms
   - windowMaximize: 400Hz → 700Hz, 150ms
   - windowRestore: 400Hz → 600Hz, 150ms
   - error: 400Hz sawtooth, 200ms
   - criticalStop: 200Hz square, 300ms
   - exclamation: 600Hz sine, 100ms
   - buttonClick: 800Hz, 30ms
   - menuOpen: 400Hz → 500Hz, 80ms
   - menuClose: 500Hz → 400Hz, 80ms

5. **Implementation pattern** for chirp:
```typescript
private playChirp(startFreq: number, endFreq: number, duration: number) {
  if (this.muted) return;
  
  const ctx = this.getContext();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  
  osc.connect(gain);
  gain.connect(ctx.destination);
  
  osc.type = 'sine';
  osc.frequency.setValueAtTime(startFreq, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(endFreq, ctx.currentTime + duration / 1000);
  
  gain.gain.setValueAtTime(this.volume, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration / 1000);
  
  osc.start(ctx.currentTime);
  osc.stop(ctx.currentTime + duration / 1000);
}
```

6. **Handle browser autoplay policy**: Wrap AudioContext creation in try-catch, log errors gracefully.

7. **Export singleton instance**: `export const soundManager = new SoundManager();`
  </action>
  <verify>
1. Run: `npx tsc --noEmit` to check TypeScript compilation
2. Check that app/lib/sounds.ts has no type errors
3. Verify all sound types are defined
4. Verify SoundManager class exports correctly
  </verify>
  <done>
SoundManager class exists in app/lib/sounds.ts with all 13 sound types implemented using Web Audio API. Volume control and mute functionality working. No external audio files used.
  </done>
</task>

<task type="auto">
  <name>Update useSoundEffects hook to use SoundManager</name>
  <files>app/hooks/useSoundEffects.ts</files>
  <action>
Refactor the existing useSoundEffects hook (currently 44 lines) to use the new SoundManager:

1. **Import SoundManager**:
```typescript
import { soundManager, type SoundType } from '@/app/lib/sounds';
```

2. **Remove old SOUNDS object** (lines 6-12) - no longer needed

3. **Simplify hook implementation**:
```typescript
export function useSoundEffects() {
  const playSound = useCallback((type: SoundType) => {
    soundManager.playSound(type);
  }, []);
  
  const setVolume = useCallback((volume: number) => {
    soundManager.setVolume(volume);
  }, []);
  
  const setMuted = useCallback((muted: boolean) => {
    soundManager.setMuted(muted);
  }, []);
  
  return { playSound, setVolume, setMuted };
}
```

4. **Keep startup sound effect** (if desired):
```typescript
useEffect(() => {
  // Optional: Play startup sound on mount
  const timeout = setTimeout(() => {
    soundManager.playSound('windowOpen'); // Repurpose as startup
  }, 500);
  return () => clearTimeout(timeout);
}, []);
```

5. **Remove unused Audio() calls** - all sound now via SoundManager
  </action>
  <verify>
1. Run: `npx tsc --noEmit`
2. Check that useSoundEffects.ts has no type errors
3. Verify hook returns playSound, setVolume, setMuted functions
4. Run: `npm run build` to ensure no build errors
  </verify>
  <done>
useSoundEffects hook refactored to use SoundManager. All old Audio() calls removed. Hook provides playSound, setVolume, and setMuted functions. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Integrate sounds into Window, StartMenu, and Minesweeper components</name>
  <files>
app/components/Window.tsx
app/components/StartMenu.tsx
app/components/apps/Minesweeper.tsx
  </files>
  <action>
Add sound effect calls to key interaction points:

**In Window.tsx:**
1. Import hook: `const { playSound } = useSoundEffects();`
2. Play sound on window state changes:
```typescript
useEffect(() => {
  if (windowState === 'minimized' && prevState !== 'minimized') {
    playSound('windowMinimize');
  } else if (windowState === 'maximized' && prevState !== 'maximized') {
    playSound('windowMaximize');
  } else if (windowState === 'normal' && prevState === 'minimized') {
    playSound('windowRestore');
  }
}, [windowState, prevState, playSound]);
```
3. Play sound on close button click: `playSound('windowClose');`
4. Play sound on window open (in useEffect on mount): `playSound('windowOpen');`

**In StartMenu.tsx:**
1. Import hook: `const { playSound } = useSoundEffects();`
2. Play sound when menu opens: `playSound('menuOpen');` (in show handler)
3. Play sound when menu closes: `playSound('menuClose');` (in hide handler)

**In Minesweeper.tsx:**
1. Import hook: `const { playSound } = useSoundEffects();`
2. Play explosion sound when mine is revealed:
```typescript
if (cell.isMine && cell.isRevealed) {
  playSound('mineExplode');
}
```

**Important**: 
- Use `useCallback` to wrap sound calls if needed to prevent re-renders
- Don't call playSound excessively (max once per interaction)
- Ensure sounds don't block UI interactions (fire-and-forget)
  </action>
  <verify>
1. Run: `npm run dev`
2. Test each integration point:
   - Open a window (Desktop icon) → should hear window open sound
   - Close a window → should hear window close sound
   - Minimize a window → should hear minimize sound
   - Maximize a window → should hear maximize sound
   - Restore from taskbar → should hear restore sound
   - Open Start menu → should hear menu open sound
   - Close Start menu → should hear menu close sound
   - Play Minesweeper, reveal a mine → should hear explosion sound
3. Check browser console for no errors
4. Verify sounds don't overlap or distort when triggered rapidly
  </verify>
  <done>
Window, StartMenu, and Minesweeper components integrated with sound effects. All window state changes, menu interactions, and game events produce appropriate sounds. No audio distortion or performance issues.
  </done>
</task>

</tasks>

<verification>
- [ ] SoundManager class compiles without TypeScript errors
- [ ] All 13 sound types implemented with Web Audio API
- [ ] useSoundEffects hook provides playSound, setVolume, setMuted
- [ ] Window operations (open, close, minimize, maximize, restore) produce sounds
- [ ] Start menu open/close produces sounds
- [ ] Minesweeper mine explosion produces sound
- [ ] No audio files (.wav, .mp3) in project
- [ ] Volume control and mute functionality working
- [ ] Multiple simultaneous sounds don't cause distortion
</verification>

<success_criteria>
- SoundManager uses Web Audio API exclusively (no audio files)
- All window state transitions produce correct sounds
- Start menu interactions have audio feedback
- Minesweeper mine explosions are audible
- Sound latency < 50ms (instant feedback)
- Volume control works (0-100%)
- Mute toggle works instantly
- No console errors or autoplay policy violations
- Sounds enhance UX without being annoying
</success_criteria>

<output>
After completion, create `.planning/phases/10-polish/10-02-SUMMARY.md`
</output>
